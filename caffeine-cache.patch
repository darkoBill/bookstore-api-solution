From df98c9b76e850938f5454cc623d72db412160115 Mon Sep 17 00:00:00 2001
From: Darko <43810203+darkoBill@users.noreply.github.com>
Date: Sun, 24 Aug 2025 19:52:20 +0200
Subject: [PATCH] Use Caffeine cache for rate limiting

---
 build.gradle.kts                              |  3 +-
 .../bookstore/config/RateLimitingConfig.java  | 30 ++++++++---
 src/main/resources/application.yml            |  5 ++
 .../config/RateLimitingConfigTest.java        | 50 +++++++++++++++++++
 4 files changed, 79 insertions(+), 9 deletions(-)
 create mode 100644 src/test/java/com/bookstore/config/RateLimitingConfigTest.java

diff --git a/build.gradle.kts b/build.gradle.kts
index 66c90b7..66551ad 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -33,8 +33,9 @@ dependencies {
     implementation("org.springframework.boot:spring-boot-starter-actuator")
     implementation("org.springframework.boot:spring-boot-starter-cache")
     implementation("org.springframework.boot:spring-boot-starter-aop")
-    
+
     implementation("com.github.vladimir-bukhtoyarov:bucket4j-core:7.6.0")
+    implementation("com.github.ben-manes.caffeine:caffeine:3.1.8")
     implementation("io.micrometer:micrometer-registry-prometheus")
     
     implementation("org.postgresql:postgresql:42.7.3")
diff --git a/src/main/java/com/bookstore/config/RateLimitingConfig.java b/src/main/java/com/bookstore/config/RateLimitingConfig.java
index bb4773b..672fe52 100644
--- a/src/main/java/com/bookstore/config/RateLimitingConfig.java
+++ b/src/main/java/com/bookstore/config/RateLimitingConfig.java
@@ -4,44 +4,58 @@ import io.github.bucket4j.Bandwidth;
 import io.github.bucket4j.Bucket;
 import io.github.bucket4j.Refill;
 import lombok.extern.slf4j.Slf4j;
-import org.springframework.context.annotation.Bean;
+import org.springframework.beans.factory.annotation.Value;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.web.servlet.HandlerInterceptor;
 import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
 import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
 
+import com.github.benmanes.caffeine.cache.Cache;
+import com.github.benmanes.caffeine.cache.Caffeine;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
 import java.time.Duration;
-import java.util.concurrent.ConcurrentHashMap;
 
 @Configuration
 @Slf4j
 public class RateLimitingConfig implements WebMvcConfigurer {
-    
-    private final ConcurrentHashMap<String, Bucket> cache = new ConcurrentHashMap<>();
+
+    private final Cache<String, Bucket> cache;
+
+    public RateLimitingConfig(
+        @Value("${rate-limit.cache.ttl:PT1M}") Duration cacheTtl,
+        @Value("${rate-limit.cache.max-size:10000}") long maxSize
+    ) {
+        this.cache = Caffeine.newBuilder()
+            .expireAfterAccess(cacheTtl)
+            .maximumSize(maxSize)
+            .build();
+    }
     
     @Override
     public void addInterceptors(InterceptorRegistry registry) {
         registry.addInterceptor(new RateLimitingInterceptor()).addPathPatterns("/api/**");
     }
     
-    @Bean
-    public Bucket createNewBucket() {
+    protected Bucket createNewBucket() {
         // Allow 100 requests per minute per IP
         Bandwidth limit = Bandwidth.classic(100, Refill.intervally(100, Duration.ofMinutes(1)));
         return Bucket.builder()
                 .addLimit(limit)
                 .build();
     }
+
+    Cache<String, Bucket> getCache() {
+        return cache;
+    }
     
-    private class RateLimitingInterceptor implements HandlerInterceptor {
+    class RateLimitingInterceptor implements HandlerInterceptor {
         
         @Override
         public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
             String clientIP = getClientIP(request);
             
-            Bucket bucket = cache.computeIfAbsent(clientIP, k -> createNewBucket());
+            Bucket bucket = cache.get(clientIP, k -> createNewBucket());
             
             if (bucket.tryConsume(1)) {
                 response.addHeader("X-Rate-Limit-Remaining", String.valueOf(bucket.getAvailableTokens()));
diff --git a/src/main/resources/application.yml b/src/main/resources/application.yml
index 4c44131..83333cb 100644
--- a/src/main/resources/application.yml
+++ b/src/main/resources/application.yml
@@ -80,6 +80,11 @@ springdoc:
     path: /swagger-ui.html
     enabled: ${SWAGGER_ENABLED:true}
 
+rate-limit:
+  cache:
+    ttl: PT1M
+    max-size: 10000
+
 app:
   security:
     admin:
diff --git a/src/test/java/com/bookstore/config/RateLimitingConfigTest.java b/src/test/java/com/bookstore/config/RateLimitingConfigTest.java
new file mode 100644
index 0000000..1ee5272
--- /dev/null
+++ b/src/test/java/com/bookstore/config/RateLimitingConfigTest.java
@@ -0,0 +1,50 @@
+package com.bookstore.config;
+
+import io.github.bucket4j.Bandwidth;
+import io.github.bucket4j.Bucket;
+import io.github.bucket4j.Refill;
+import org.junit.jupiter.api.Test;
+import org.springframework.mock.web.MockHttpServletRequest;
+import org.springframework.mock.web.MockHttpServletResponse;
+import org.springframework.web.servlet.HandlerInterceptor;
+
+import java.time.Duration;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+class RateLimitingConfigTest {
+
+    @Test
+    void bucketShouldBeEvictedAfterTtlAndRateLimitingReset() throws Exception {
+        RateLimitingConfig config = new RateLimitingConfig(Duration.ofMillis(100), 1000) {
+            @Override
+            protected Bucket createNewBucket() {
+                Bandwidth limit = Bandwidth.classic(1, Refill.intervally(1, Duration.ofHours(1)));
+                return Bucket.builder().addLimit(limit).build();
+            }
+        };
+
+        HandlerInterceptor interceptor = config.new RateLimitingInterceptor();
+        String clientIp = "127.0.0.1";
+
+        MockHttpServletRequest request = new MockHttpServletRequest();
+        request.setRemoteAddr(clientIp);
+
+        MockHttpServletResponse response1 = new MockHttpServletResponse();
+        assertThat(interceptor.preHandle(request, response1, new Object())).isTrue();
+
+        // Second request immediately should be rate limited
+        MockHttpServletResponse response2 = new MockHttpServletResponse();
+        assertThat(interceptor.preHandle(request, response2, new Object())).isFalse();
+
+        Bucket firstBucket = config.getCache().getIfPresent(clientIp);
+
+        Thread.sleep(200); // wait for TTL expiration
+
+        MockHttpServletResponse response3 = new MockHttpServletResponse();
+        assertThat(interceptor.preHandle(request, response3, new Object())).isTrue();
+
+        Bucket secondBucket = config.getCache().getIfPresent(clientIp);
+        assertThat(secondBucket).isNotSameAs(firstBucket);
+    }
+}
-- 
2.43.0

